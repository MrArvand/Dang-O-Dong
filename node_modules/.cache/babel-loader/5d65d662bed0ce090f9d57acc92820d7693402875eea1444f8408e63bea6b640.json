{"ast":null,"code":"// Calculate total expenses for each member\nexport const calculateMemberTotals=expenses=>{const memberTotals={};expenses.forEach(expense=>{const{payer,amount,participants}=expense;const perPersonAmount=Math.floor(amount/participants.length);// The payer paid the full amount upfront\nmemberTotals[payer]=(memberTotals[payer]||0)+amount;// Each participant owes their share\nparticipants.forEach(participant=>{memberTotals[participant]=(memberTotals[participant]||0)-perPersonAmount;});});return memberTotals;};// Calculate optimal settlements\nexport const calculateSettlements=memberTotals=>{const creditors=[];const debtors=[];// Separate creditors and debtors\nObject.entries(memberTotals).forEach(_ref=>{let[member,balance]=_ref;if(balance>0){// Consider only positive amounts\ncreditors.push({member,amount:balance});}else if(balance<0){// Consider only negative amounts\ndebtors.push({member,amount:Math.abs(balance)});}});// Sort by amount (highest first)\ncreditors.sort((a,b)=>b.amount-a.amount);debtors.sort((a,b)=>b.amount-a.amount);const settlements=[];// Calculate optimal payments\nfor(const debtor of debtors){let remainingDebt=debtor.amount;for(const creditor of creditors){if(remainingDebt<=0||creditor.amount<=0)break;const paymentAmount=Math.min(remainingDebt,creditor.amount);settlements.push({from:debtor.member,to:creditor.member,amount:paymentAmount});remainingDebt=remainingDebt-paymentAmount;creditor.amount=creditor.amount-paymentAmount;}}return settlements;};// Get member balance\nexport const getMemberBalance=(memberId,memberTotals)=>{return memberTotals[memberId]||0;};// Check if member is creditor or debtor\nexport const getMemberStatus=balance=>{if(balance>0)return'creditor';if(balance<0)return'debtor';return'balanced';};// Calculate total amount paid by a member\nexport const calculateTotalPaid=(memberId,expenses)=>{return expenses.filter(expense=>expense.payer===memberId).reduce((sum,expense)=>sum+expense.amount,0);};// Calculate total amount a member owes (their share in all expenses they participated in)\nexport const calculateTotalOwed=(memberId,expenses)=>{return expenses.filter(expense=>expense.participants.includes(memberId)).reduce((sum,expense)=>{const perPersonAmount=Math.floor(expense.amount/expense.participants.length);return sum+perPersonAmount;},0);};// Calculate net balance for a member (paid - owed)\nexport const calculateNetBalance=(memberId,expenses)=>{const totalPaid=calculateTotalPaid(memberId,expenses);const totalOwed=calculateTotalOwed(memberId,expenses);return totalPaid-totalOwed;};// Validate that all calculations are correct (sum of all balances should be 0)\nexport const validateCalculations=(expenses,memberTotals)=>{const totalPaid=expenses.reduce((sum,expense)=>sum+expense.amount,0);const totalOwed=expenses.reduce((sum,expense)=>{const perPersonAmount=Math.floor(expense.amount/expense.participants.length);return sum+perPersonAmount*expense.participants.length;},0);const sumOfBalances=Object.values(memberTotals).reduce((sum,balance)=>sum+balance,0);return{isValid:sumOfBalances===0,totalPaid,totalOwed,sumOfBalances,difference:Math.abs(totalPaid-totalOwed)};};// Test function to verify calculation logic\nexport const testCalculation=()=>{const testExpenses=[{id:'1',description:'شام',amount:100000,payer:'user1',participants:['user1','user2','user3'],date:new Date().toISOString()},{id:'2',description:'تاکسی',amount:50000,payer:'user2',participants:['user1','user2'],date:new Date().toISOString()}];const memberTotals=calculateMemberTotals(testExpenses);console.log('Test Calculation Results:');console.log('Member Totals:',memberTotals);console.log('Validation:',validateCalculations(testExpenses,memberTotals));return memberTotals;};","map":{"version":3,"names":["calculateMemberTotals","expenses","memberTotals","forEach","expense","payer","amount","participants","perPersonAmount","Math","floor","length","participant","calculateSettlements","creditors","debtors","Object","entries","_ref","member","balance","push","abs","sort","a","b","settlements","debtor","remainingDebt","creditor","paymentAmount","min","from","to","getMemberBalance","memberId","getMemberStatus","calculateTotalPaid","filter","reduce","sum","calculateTotalOwed","includes","calculateNetBalance","totalPaid","totalOwed","validateCalculations","sumOfBalances","values","isValid","difference","testCalculation","testExpenses","id","description","date","Date","toISOString","console","log"],"sources":["/home/runner/work/Dang-O-Dong/Dang-O-Dong/src/utils/calculationUtils.js"],"sourcesContent":["// Calculate total expenses for each member\nexport const calculateMemberTotals = (expenses) => {\n  const memberTotals = {};\n\n  expenses.forEach(expense => {\n    const { payer, amount, participants } = expense;\n    const perPersonAmount = Math.floor(amount / participants.length);\n\n    // The payer paid the full amount upfront\n    memberTotals[payer] = (memberTotals[payer] || 0) + amount;\n\n    // Each participant owes their share\n    participants.forEach(participant => {\n      memberTotals[participant] = (memberTotals[participant] || 0) - perPersonAmount;\n    });\n  });\n\n  return memberTotals;\n};\n\n// Calculate optimal settlements\nexport const calculateSettlements = (memberTotals) => {\n  const creditors = [];\n  const debtors = [];\n\n  // Separate creditors and debtors\n  Object.entries(memberTotals).forEach(([member, balance]) => {\n    if (balance > 0) { // Consider only positive amounts\n      creditors.push({ member, amount: balance });\n    } else if (balance < 0) { // Consider only negative amounts\n      debtors.push({ member, amount: Math.abs(balance) });\n    }\n  });\n\n  // Sort by amount (highest first)\n  creditors.sort((a, b) => b.amount - a.amount);\n  debtors.sort((a, b) => b.amount - a.amount);\n\n  const settlements = [];\n\n  // Calculate optimal payments\n  for (const debtor of debtors) {\n    let remainingDebt = debtor.amount;\n\n    for (const creditor of creditors) {\n      if (remainingDebt <= 0 || creditor.amount <= 0) break;\n\n      const paymentAmount = Math.min(remainingDebt, creditor.amount);\n\n      settlements.push({\n        from: debtor.member,\n        to: creditor.member,\n        amount: paymentAmount\n      });\n\n      remainingDebt = remainingDebt - paymentAmount;\n      creditor.amount = creditor.amount - paymentAmount;\n    }\n  }\n\n  return settlements;\n};\n\n// Get member balance\nexport const getMemberBalance = (memberId, memberTotals) => {\n  return memberTotals[memberId] || 0;\n};\n\n// Check if member is creditor or debtor\nexport const getMemberStatus = (balance) => {\n  if (balance > 0) return 'creditor';\n  if (balance < 0) return 'debtor';\n  return 'balanced';\n};\n\n// Calculate total amount paid by a member\nexport const calculateTotalPaid = (memberId, expenses) => {\n  return expenses\n    .filter(expense => expense.payer === memberId)\n    .reduce((sum, expense) => sum + expense.amount, 0);\n};\n\n// Calculate total amount a member owes (their share in all expenses they participated in)\nexport const calculateTotalOwed = (memberId, expenses) => {\n  return expenses\n    .filter(expense => expense.participants.includes(memberId))\n    .reduce((sum, expense) => {\n      const perPersonAmount = Math.floor(expense.amount / expense.participants.length);\n      return sum + perPersonAmount;\n    }, 0);\n};\n\n// Calculate net balance for a member (paid - owed)\nexport const calculateNetBalance = (memberId, expenses) => {\n  const totalPaid = calculateTotalPaid(memberId, expenses);\n  const totalOwed = calculateTotalOwed(memberId, expenses);\n  return totalPaid - totalOwed;\n};\n\n// Validate that all calculations are correct (sum of all balances should be 0)\nexport const validateCalculations = (expenses, memberTotals) => {\n  const totalPaid = expenses.reduce((sum, expense) => sum + expense.amount, 0);\n  const totalOwed = expenses.reduce((sum, expense) => {\n    const perPersonAmount = Math.floor(expense.amount / expense.participants.length);\n    return sum + (perPersonAmount * expense.participants.length);\n  }, 0);\n\n  const sumOfBalances = Object.values(memberTotals).reduce((sum, balance) => sum + balance, 0);\n\n  return {\n    isValid: sumOfBalances === 0,\n    totalPaid,\n    totalOwed,\n    sumOfBalances,\n    difference: Math.abs(totalPaid - totalOwed)\n  };\n};\n\n// Test function to verify calculation logic\nexport const testCalculation = () => {\n  const testExpenses = [\n    {\n      id: '1',\n      description: 'شام',\n      amount: 100000,\n      payer: 'user1',\n      participants: ['user1', 'user2', 'user3'],\n      date: new Date().toISOString()\n    },\n    {\n      id: '2',\n      description: 'تاکسی',\n      amount: 50000,\n      payer: 'user2',\n      participants: ['user1', 'user2'],\n      date: new Date().toISOString()\n    }\n  ];\n\n  const memberTotals = calculateMemberTotals(testExpenses);\n  console.log('Test Calculation Results:');\n  console.log('Member Totals:', memberTotals);\n  console.log('Validation:', validateCalculations(testExpenses, memberTotals));\n\n  return memberTotals;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}